---
title: "Project 2 - Main script"
author: "Jerome Kafrouni, Ayano Kase, Joo Kim, Chunzi Wang, Xiaoxuan Yang, Chuyuan Zhou"
date: "March 5, 2018"
output:
  pdf_document: default
  html_document: default
---
In your final Project 2 repo, there should be an R markdown file called `main.Rmd` that organizes **all computational steps** for evaluating your proposed image classification framework. 

This file is meant to be a template for evaluating models used for image analysis (and could be generalized for any predictive modeling). You should update it according to your models/codes but your final document should have precisely the same structure. 


```{r, warning = FALSE}

packages.used=c("gbm", "knn", "xgboost", "randomForest", "ggplot2", "OpenImageR", "grDevices")
# check packages that need to be installed.
packages.needed=setdiff(packages.used,
intersect(installed.packages()[,1],
packages.used))
# install additional packages
if(length(packages.needed)>0){
install.packages(packages.needed, dependencies = TRUE)
}

if(!require("EBImage")){
  source("https://bioconductor.org/biocLite.R")
  biocLite("EBImage")
}
```

### Step 0: Specify directories.

We first set the working directory to the location of this .Rmd file  (it should be in a project folder). Then we specify our training and testing data. If you do not have an independent test set, you need to create your own testing data by random subsampling from the training data (we haven't done this here), and in order to obain reproducible results, you should use `set.seed()` whenever randomization is used. 


```{r wkdir, eval=FALSE}
setwd("/Users/jookim/Documents/GitHub/project-2-predictive-modelling-group-2")
# Replace the above with your own path or manually set it in RStudio to where this rmd file is located. 
```

Now we provide directories for the raw images. Here we assume the training set and test set are in different subfolders. 
```{r}
experiment_dir <- "../data/pets/" # This will be modified for different data sets.
img_train_dir  <- paste(experiment_dir, "train/", sep="")
img_test_dir   <- paste(experiment_dir, "test/", sep="")
```

### Step 1: Set up controls for model evaluation.

In this step, we have a set of controls for the model evaluation.  The code in the rest of the document runs (or not) according to our choices here. 

+ (TRUE/FALSE) run cross-validation on the training set
+ (number) K, the number of CV folds
+ (TRUE/FALSE) process features for training set
+ (TRUE/FALSE) run evaluation on an independent test set
+ (TRUE/FALSE) process features for test set

```{r exp_setup}
run.cv            <- TRUE # run cross-validation on the training set
K                 <- 5    # number of CV folds
run.feature.train <- TRUE # process features for training set
run.test          <- FALSE # run evaluation on an independent test set
run.feature.test  <- FALSE # process features for test set
```

Using cross-validation or independent test set evaluation, we compare the performance of different classifiers. 

A model can take one (for gbm for example) or more values. Construct a list with all the values that you want to test, each entry of the list should be one test.

For example, if you have two parameters:
- my_param_a: you want to test it on 1,2,3
- my_param_b: you want to test it on 0.1,0.2

Then your list of model_values should be the cross product of those if you want to try any combination of the two, and each element of the list should contain the name of the parameter and its value:

```
list(list(my_param_a=1, my_param_b=0.1), list(my_param_a=1, my_param_b=0.2),
     list(my_param_a=2, my_param_b=0.1), list(my_param_a=2, my_param_b=0.2),
     list(my_param_a=3, my_param_b=0.1), list(my_param_a=3, my_param_b=0.2))
```   

```{r model_setup}
# Model values for GBM:
# model_values <- seq(3, 11, 2)
# model_labels <- paste("GBM with depth =", model_values)

# Model values for xgboost (only one parameter):
# model_values <- list()
# k = 1
# for(i in list(1, 2, 3, 4, 5, 10)){
#   model_values[[k]] = list(depth = i)
#   k = k + 1
# }

# Model values for randomForest (two parameters: ntree and mtry)
model_values <- list()
k = 1
for(i in seq(300, 500, 100)){
  for(j in seq(50, 100, 10)){
    model_values[[k]] = list(ntree = i, mtry = j)
    k = k + 1
  }
}

# model_labels <- paste("XGboost with max_depth =", model_values)
```


### Step 2: Import training images class labels.

"cat" will be label 1, and "dog" label 0.
```{r train_label}
label_train <- read.table(paste(experiment_dir, "train_label.txt", sep = ""), header = F)
label_train <- as.numeric(unlist(label_train) == "cat")
```

### Step 3: Construct visual features

When debugging, do not pass all the training data to the 'feature' function, otherwise it'll take a while. Instead pass a subset, via the argument "indexes" of the function. It should be a sequence of integers corresponding to the training samples you want to use.

```{r}
# train_indexes <- seq(1, 100) # set to "all" if you want to train on full dataset
train_indexes <- "all"
```


```{r feature}
source("../lib/feature.R")

tm_feature_train <- NA

if(run.feature.train){
 tm_feature_train <- system.time(dat_train <- feature(img_train_dir, indexes=train_indexes,
                                                      method="hsv", export = FALSE))
}

tm_feature_test <- NA
if(run.feature.test){
  tm_feature_test <- system.time(dat_test <- feature(img_train_dir, indexes = "all",
                                                      export = FALSE))
}

#save(dat_train, file = "../output/feature_train.RData")
#save(dat_test, file = "../output/feature_test.RData")
```

#### Dealing with imbalanced data:

There are more dogs than cats in our training data which is not representative of the true distribution, therefore our model will be more biased toward dogs. As a basic approach, we just remove images of dogs from the dataset to make sure to have an equal number of pictures of dogs and cats. This is suboptimal because we are removing a lot of training samples.

There are 652 images of cats and 1358 imgaes of dogs so we'll drop 706 images of dogs. Again, this is not optimal at all.
```{r}
dogs_indexes <- which(label_train == 0)
cats_indexes <- which(label_train == 1)

dat_train <- dat_train[c(dogs_indexes[1:652], cats_indexes),]
label_train <- label_train[c(dogs_indexes[1:652], cats_indexes)]
```


###Step 4: Train a classification model with training images (and the visual features constructed above)

Call the train model and test model from library. 

`train.R` and `test.R` should be wrappers for all your model training steps and your classification/prediction steps. 
+ `train.R`
  + Input: a path that points to the training set features.
  + Input: an R object of training sample labels.
  + Output: an RData file that contains trained classifiers in the forms of R objects: models/settings/links to external trained configurations.
+ `test.R`
  + Input: a path that points to the test set features.
  + Input: an R object that contains a trained classifier.
  + Output: an R object of class label predictions on the test set. If there are multiple classifiers under evaluation, there should be multiple sets of label predictions. 
  
```{r loadlib}
source("../lib/train.R")
source("../lib/test.R")
```

#### Model selection with cross-validation

* Do model selection.  Here we choose between model parameters, in this case the interaction depth for GBM. 

```{r runcv, message=FALSE, warning=FALSE}
source("../lib/cross_validation.R")

# if you're testing on a subset of the data, for debugging purposes:
# (note that you can't do cv if you don't have enough samples (less than 100) even for debbuging)
if (train_indexes != "all"){
  label_train <- label_train[train_indexes]
}

model = "randomForest"
# model = "gbm"

if(run.cv){
  err_cv <- array(dim = c(length(model_values), 2))
  for(k in 1:length(model_values)){
    cat("k=", k, "\n")
    err_cv[k,] <- cv.function(dat_train, label_train, model_values[[k]], model, K)
    print(paste0('err for this k: ', err_cv[k,]))
  }
  save(err_cv, file = paste0("../output/err_cv_", model, ".RData"))
}

```

* Visualize the cross-validation results. 


If the model we use is only tuned with 1 parameter, we visualize the results by simply plotting the cv error, with the parameter we're tuning on the x axis.
If the model uses 2 parameters, we visualize the results with a heatmap.
```{r cv_vis}
library(ggplot2)
if(run.cv){
  # load("../output/err_cv.RData")
  # pdf("../fig/cv_results.pdf", width=7, height=5)
  if (length(model_values[[1]]) == 1){
    # plot, like in the starter code
    plot(as.vector(unlist(model_values)), err_cv[,1], xlab = "Interaction Depth", ylab = "CV Error",
         main = "Cross Validation Error", type = "n", ylim = c(0, 0.25))
    points(as.vector(unlist(model_values)), err_cv[,1], col = "blue", pch=16)
    lines(as.vector(unlist(model_values)), err_cv[,1], col = "blue")
    arrows(as.vector(unlist(model_values)), err_cv[,1] - err_cv[,2], as.vector(unlist(model_values)), err_cv[,1] + err_cv[,2],
           length = 0.1, angle = 90, code = 3)
  
  } else if(length(model_values[[1]]) == 2){
    # do a heatmap
    par_1_name = names(model_values[[1]])[1]
    par_2_name = names(model_values[[1]])[2]
    
    par_1 = sapply(model_values, function(x) as.numeric(x[1]))
    par_2 = sapply(model_values, function(x) as.numeric(x[2]))
    # construct a dataframe containing for each row the value of 1st param, the value of 2nd param, and the cv results (mean error and std of error)
    err = data.frame(par_1, par_2, mean_err_cv = err_cv[,1], std_err_cv = err_cv[,2])

    # plot those results in a 2d heatmap
    ggplot(data = err[,c(1,2,3)], aes(x=par_1, y=par_2, fill=mean_err_cv)) + 
      geom_tile() +
      geom_text(aes(par_1, par_2, label = round(mean_err_cv, digits=2)), color = "black", size = 4) +
      # scale_fill_gradient2(low = "green", high = "red", mid = "white", 
      #   midpoint = 0.5, limit = c(0, 1), space = "Lab") +
      labs(x=par_1_name, y=par_2_name) +
      theme(
        panel.grid.major = element_blank(),
        panel.background = element_blank()
      )
    
  } else{
    # TODO: handle visualization for 3 parameters or mroe
  }
  
  #dev.off()
}
```

* Choose the "best" parameter value

```{r best_model}
model_best <- model_values[1]
if(run.cv){
  model_best <- model_values[which.min(err_cv[, 1])]
}

par_best <- list(ntree = model_best$ntree, mtry = model_best$mtry)
```

* Train the model with the entire training set using the selected model (in this case, model parameter) via cross-validation.


```{r final_train}
# tm_train <- NA
# tm_train <- system.time(fit_train <- train(dat_train, label_train, par_best))
# save(fit_train, file = "../output/fit_train.RData")
```

### Step 5: Make prediction 

Feed the final training model with the test data.  (Note that for this to truly be 'test' data, it should have had no part of the training procedure used above.) 

```{r test}
# tm_test <- NA
# if(run.test){
#   load(file = paste0("../output/feature_", "zip", "_", "test", ".RData"))
#   load(file = "../output/fit_train.RData")
#   tm_test <- system.time(pred_test <- test(fit_train, dat_test))
#   save(pred_test, file = "../output/pred_test.RData")
# }
```

### Summarize Running Time

Prediction performance matters, so does the running times for constructing features and for training the model, especially when the computation resource is limited. 

```{r running_time}
cat("Time for constructing training features=", tm_feature_train[1], "s \n")
# cat("Time for constructing testing features=", tm_feature_test[1], "s \n")
# cat("Time for training model=", tm_train[1], "s \n")
# cat("Time for making prediction=", tm_test[1], "s \n")
```